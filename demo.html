<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šAgentäº¤äº’æ¨¡æ‹Ÿç³»ç»Ÿ (ä¼˜åŒ–ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            overflow: hidden;
        }
        .map {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #f0f4f8;
            border-radius: 0.5rem;
            overflow: hidden;
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.04) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.04) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .agent {
            position: absolute;
            width: 64px;
            height: 64px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .agent:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 12px rgba(0,0,0,0.15);
        }
        .agent-avatar {
            font-size: 24px;
        }
        .agent-name {
            font-size: 10px;
            font-weight: 500;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .chat-bubble {
            position: absolute;
            bottom: 75px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 12px;
            max-width: 200px;
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 10;
            border: 1px solid #e2e8f0;
        }
        .chat-bubble.visible {
            opacity: 1;
        }
        .status-indicator {
            position: absolute;
            top: 0;
            right: 0;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
        }
        .status-wandering { background-color: #34d399; } /* green */
        .status-talking { background-color: #fbbf24; } /* amber */
        .status-finding { background-color: #f87171; } /* red */
        .status-thinking { background-color: #60a5fa; } /* blue */

        .log-panel {
            height: 100%;
            overflow-y: auto;
            background-color: #ffffff;
            border-left: 1px solid #e2e8f0;
        }
        .log-item {
            padding: 8px 12px;
            border-bottom: 1px solid #f1f5f9;
            font-size: 13px;
        }
        .log-item.system { color: #64748b; font-style: italic; }
        .log-item.dialogue { color: #1e293b; }
        .log-item.event { background-color: #e0f2fe; color: #0c4a6e; font-weight: 500; border-left: 4px solid #0ea5e9; }
        .log-item.memory { background-color: #fefce8; color: #854d0e; font-style: italic; border-left: 4px solid #facc15;}

        .selected-agent-panel {
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
        }
        .control-button {
            background-color: #8b5cf6;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .control-button:hover {
            background-color: #7c3aed;
            transform: translateY(-2px);
        }
        .control-button:disabled {
            background-color: #a78bfa;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="w-screen h-screen p-4 flex gap-4">
        <!-- Main Map Area -->
        <div class="w-3/4 h-full flex flex-col gap-4">
            <div class="flex-grow relative">
                <div id="map" class="map"></div>
                <div id="controls" class="absolute top-2 left-2 flex gap-2">
                    <button id="start-sim-btn" class="control-button">ğŸš€ å¼€å§‹æ¨¡æ‹Ÿ</button>
                    <button id="event-trigger-btn" class="control-button hidden">âœ¨ è§¦å‘ä¸–ç•Œäº‹ä»¶</button>
                </div>
            </div>
            <div id="selected-agent-panel" class="h-48 p-4 border border-gray-200 rounded-lg shadow-sm selected-agent-panel hidden">
                <h3 class="font-bold text-lg">é€‰ä¸­çš„Agentä¿¡æ¯</h3>
                <div id="agent-details" class="mt-2 text-sm grid grid-cols-2 gap-x-4"></div>
            </div>
        </div>

        <!-- Log Panel -->
        <div class="w-1/4 h-full flex flex-col bg-white rounded-lg shadow-md">
            <h2 class="text-lg font-bold p-4 border-b border-gray-200">ç³»ç»Ÿæ—¥å¿—ä¸å¯¹è¯</h2>
            <div id="log-panel" class="flex-grow overflow-y-auto p-2">
                <!-- Logs will be appended here -->
            </div>
        </div>
    </div>

<script>
// --- CONFIGURATION ---
const apiKey = ""; // This is a placeholder, the environment will handle authentication.
const modelName = "gemini-2.0-flash";
const baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent`;

const AGENT_SPEED = 1.5; // **FIX**: Increased speed
const ENCOUNTER_DISTANCE = 100;
const GAME_TICK_MS = 100;
const TALK_INITIATION_COOLDOWN = 10000;
const MAX_CONVERSATION_TURNS = 10;

// --- DOM ELEMENTS ---
const mapElement = document.getElementById('map');
const logPanel = document.getElementById('log-panel');
const selectedAgentPanel = document.getElementById('selected-agent-panel');
const agentDetails = document.getElementById('agent-details');
const startSimBtn = document.getElementById('start-sim-btn');
const eventTriggerBtn = document.getElementById('event-trigger-btn');


// --- GLOBAL STATE ---
const PROFESSIONS = {
    "ç¨‹åºå‘˜": { emoji: "ğŸ’»", color: "bg-blue-500" },
    "è®¾è®¡å¸ˆ": { emoji: "ğŸ¨", color: "bg-purple-500" },
    "äº§å“ç»ç†": { emoji: "ğŸ“ˆ", color: "bg-green-500" },
    "è‰ºæœ¯å®¶": { emoji: "ğŸ­", color: "bg-pink-500" },
    "AIä¸“å®¶": { emoji: "ğŸ¤–", color: "bg-indigo-500" }
};
let agents = [];
let conversations = {};
let nextAgentId = 0;
let currentWorldEvent = null;
let simulationStarted = false;

// --- UTILITY FUNCTIONS ---
const getRandomPosition = () => ({
    x: Math.random() * (mapElement.clientWidth - 64),
    y: Math.random() * (mapElement.clientHeight - 64)
});

const getDistance = (agent1, agent2) => {
    return Math.sqrt(Math.pow(agent1.x - agent2.x, 2) + Math.pow(agent1.y - agent2.y, 2));
};

function logMessage(message, type = 'system') {
    const item = document.createElement('div');
    item.className = `log-item ${type}`;
    item.innerHTML = message;
    logPanel.appendChild(item);
    logPanel.scrollTop = logPanel.scrollHeight;
}

// --- GEMINI API CALLER ---
async function callGemini(prompt) {
    try {
        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
                responseMimeType: "application/json",
            }
        };
        const finalUrl = `${baseUrl}?key=${apiKey}`;

        const response = await fetch(finalUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`API call failed with status: ${response.status}. Body: ${errorBody}`);
        }
        const data = await response.json();
        if (data.candidates && data.candidates.length > 0) {
            const rawText = data.candidates[0].content.parts[0].text;
            try {
                return JSON.parse(rawText);
            } catch (e) {
                console.error("Failed to parse JSON from Gemini:", rawText);
                throw new Error("Invalid JSON response from API.");
            }
        }
        throw new Error("Invalid response structure from API.");
    } catch (error) {
        console.error("Gemini API Error:", error);
        logMessage(`â—ï¸ APIè°ƒç”¨å¤±è´¥: ${error.message}`, 'system');
        return { error: true, message: error.message };
    }
}

// --- AGENT CLASS ---
class Agent {
    constructor(name, profession) {
        this.id = `agent-${nextAgentId++}`;
        this.name = name;
        this.profession = profession;
        const pos = getRandomPosition();
        this.x = pos.x;
        this.y = pos.y;
        this.state = 'wandering';
        this.motivation = { action: 'wander' };
        this.target = getRandomPosition();
        this.lastEncounterCheck = {};
        this.conversationId = null;
        this.lastMessage = "";
        this.memory = [];
        this.createElement();
    }

    createElement() {
        this.element = document.createElement('div');
        this.element.id = this.id;
        this.element.className = `agent ${PROFESSIONS[this.profession].color}`;
        this.element.innerHTML = `
            <div class="agent-avatar">${PROFESSIONS[this.profession].emoji}</div>
            <div class="agent-name">${this.name}</div>
            <div class="status-indicator"></div>
            <div class="chat-bubble"></div>
        `;
        mapElement.appendChild(this.element);
        this.element.addEventListener('click', () => this.showDetails());
    }

    update() {
        this.move();
        this.updateElement();
    }

    move() {
        if (this.state === 'talking' || this.state === 'thinking' || !simulationStarted) return;
        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 5) {
            if (this.state === 'finding') {
                this.setWandering(`åœ¨å¯»æ‰¾${this.motivation.target_profession}åå¼€å§‹é—²é€›`);
            } else {
                this.target = getRandomPosition();
            }
        } else {
            this.x += (dx / distance) * AGENT_SPEED;
            this.y += (dy / distance) * AGENT_SPEED;
        }
    }
    
    setWandering(reason) {
        if (this.state === 'talking') {
             logMessage(`ğŸš¶ ${this.name} ç»“æŸäº†å¯¹è¯å¹¶å¼€å§‹é—²é€›ã€‚åŸå› : ${reason}`);
        }
        this.state = 'wandering';
        this.motivation = { action: 'wander' };
        this.target = getRandomPosition();
        this.conversationId = null;
    }

    setFinding(targetProfession, reason) {
        logMessage(`ğŸ¯ ${this.name} å†³å®šå»å¯»æ‰¾ä¸€ä½ ${targetProfession}ã€‚åŸå› : ${reason}`);
        this.state = 'finding';
        this.motivation = { action: 'find', target: targetProfession };
        this.conversationId = null;
        const targetAgent = agents.find(a => a.profession === targetProfession && a.id !== this.id);
        if (targetAgent) {
            this.target = { x: targetAgent.x, y: targetAgent.y };
            logMessage(`${this.name} å‘ç°äº† ${targetAgent.name} (${targetProfession})ï¼Œæ­£åœ¨å‰å¾€ã€‚`);
        } else {
            this.target = getRandomPosition();
            logMessage(`åœ°å›¾ä¸Šæš‚æ—¶æ²¡æœ‰ ${targetProfession}ï¼Œ${this.name} å…ˆå››å¤„çœ‹çœ‹ã€‚`);
        }
    }

    updateElement() {
        this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
        const statusIndicator = this.element.querySelector('.status-indicator');
        statusIndicator.className = `status-indicator status-${this.state}`;
    }
    
    showDetails() {
        selectedAgentPanel.classList.remove('hidden');
        const memoryHtml = this.memory.length > 0 ? this.memory.map(m => `<li>- ${m}</li>`).join('') : '<li>æš‚æ— è®°å¿†</li>';
        agentDetails.innerHTML = `
            <div>
                <p><strong>å§“å:</strong> ${this.name} (${this.id})</p>
                <p><strong>èŒä¸š:</strong> ${this.profession}</p>
                <p><strong>çŠ¶æ€:</strong> ${this.state}</p>
                <p><strong>æœ€è¿‘çš„è¯:</strong> ${this.lastMessage || 'æ— '}</p>
                <div class="mt-2">
                    <strong>è®°å¿†:</strong>
                    <ul class="list-disc list-inside text-xs h-16 overflow-y-auto">${memoryHtml}</ul>
                </div>
            </div>
            <div class="flex flex-col items-start gap-2">
                 <button onclick="viewInnerThoughts('${this.id}')" class="control-button" style="font-size:12px; padding: 4px 8px;">âœ¨ æŸ¥çœ‹å†…å¿ƒæƒ³æ³•</button>
                 <div id="thought-bubble" class="text-xs italic text-gray-600 mt-1 p-2 bg-gray-100 rounded">ç‚¹å‡»æŒ‰é’®æ¥æŸ¥çœ‹...</div>
            </div>
        `;
    }

    displayBubble(message) {
        this.lastMessage = message;
        const bubble = this.element.querySelector('.chat-bubble');
        bubble.textContent = message;
        bubble.classList.add('visible');
        setTimeout(() => bubble.classList.remove('visible'), 5000);
    }

    async decideToTalk(otherAgent) {
        this.state = 'thinking';
        const eventContext = currentWorldEvent ? `å½“å‰ä¸–ç•Œäº‹ä»¶æ˜¯: "${currentWorldEvent.description}".` : "å½“å‰æ²¡æœ‰ç‰¹æ®Šäº‹ä»¶å‘ç”Ÿã€‚";
        const memoryContext = this.memory.length > 0 ? `ä½ çš„è®°å¿†ä¸­æœ‰è¿™äº›è¿‡å»çš„äº’åŠ¨æ‘˜è¦:\n- ${this.memory.join('\n- ')}` : "ä½ è¿˜æ²¡æœ‰ä»»ä½•è¿‡å»çš„äº’åŠ¨è®°å¿†ã€‚";

        const prompt = `ä½ å« ${this.name}ï¼Œæ˜¯ä¸€å${this.profession}ã€‚
        ${memoryContext}
        ${eventContext}
        ä½ å½“å‰çš„åŠ¨æœºæ˜¯ ${JSON.stringify(this.motivation)}ã€‚
        ä½ ç°åœ¨é‡åˆ°äº† ${otherAgent.name} (${otherAgent.profession})ã€‚
        åŸºäºä½ çš„è®°å¿†å’Œå½“å‰æƒ…å†µï¼Œä½ æ˜¯å¦æƒ³å’ŒTAå‘èµ·å¯¹è¯ï¼Ÿè¯·åªè¿”å›ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼ä¸º: {"should_initiate": boolean, "reason": "ä½ çš„ç†ç”±"}`;
        
        const decision = await callGemini(prompt);
        if (decision.error) {
            return { should_initiate: false, reason: `AIå†³ç­–æ—¶å‘ç”Ÿé”™è¯¯: ${decision.message}` };
        }
        return decision;
    }
    
    async generateDialogue(conversation) {
        this.state = 'thinking';
        const otherAgent = agents.find(a => a.id === conversation.participants.find(pId => pId !== this.id));
        const history = conversation.history.map(h => `${h.name}: ${h.dialogue}`).join('\n');
        const eventContext = currentWorldEvent ? `å½“å‰ä¸–ç•Œäº‹ä»¶æ˜¯: "${currentWorldEvent.description}".` : "å½“å‰æ²¡æœ‰ç‰¹æ®Šäº‹ä»¶å‘ç”Ÿã€‚";
        const memoryContext = this.memory.length > 0 ? `ä½ çš„è®°å¿†ä¸­æœ‰è¿™äº›è¿‡å»çš„äº’åŠ¨æ‘˜è¦:\n- ${this.memory.join('\n- ')}` : "ä½ è¿˜æ²¡æœ‰ä»»ä½•è¿‡å»çš„äº’åŠ¨è®°å¿†ã€‚";

        const prompt = `
        ä½ å« ${this.name}ï¼Œæ˜¯ä¸€å${this.profession}ã€‚
        è§„åˆ™: ä½ çš„è¯è¦ç®€çŸ­ã€ç›´æ¥ï¼Œä¸è¦å¤ªå®¢æ°”ã€‚
        ä½ çš„è®°å¿†:
        ${this.memory.join('\n')}
        
        å½“å‰æƒ…æ™¯:
        å¤§èƒŒæ™¯: ${eventContext}
        ä½ æ­£åœ¨å’Œ ${otherAgent.name} (${otherAgent.profession}) å¯¹è¯ã€‚
        å¯¹è¯å†å²:
        ${history || "ï¼ˆè¿™æ˜¯å¯¹è¯çš„ç¬¬ä¸€å¥è¯ï¼‰"}

        ç°åœ¨è½®åˆ°ä½ å‘è¨€ã€‚è¯·æ ¹æ®ä½ çš„è®°å¿†å’Œå½“å‰å¯¹è¯ï¼Œç”Ÿæˆä½ çš„ä¸‹ä¸€å¥è¯ï¼Œå¹¶å†³å®šä¸‹ä¸€æ­¥è¡ŒåŠ¨ã€‚
        è¡ŒåŠ¨é€‰é¡¹: "continue_talking", "leave_and_wander", "leave_and_find"ã€‚
        è¯·åªè¿”å›ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼ä¸º:
        { "dialogue": "ä½ è¦è¯´çš„è¯", "action": { "action": "..." } }
        `;
        
        const response = await callGemini(prompt);
        if (this.state === 'thinking') this.state = 'talking';
        if (response.error) {
            return { dialogue: "æˆ‘å¥½åƒæœ‰ç‚¹èµ°ç¥äº†...", action: { action: "leave_and_wander" } };
        }
        return response;
    }
}

// --- NEW/UPDATED FEATURES ---
function startSimulation() {
    simulationStarted = true;
    startSimBtn.classList.add('hidden');
    eventTriggerBtn.classList.remove('hidden');
    logMessage("ğŸš€ æ¨¡æ‹Ÿå·²å¼€å§‹ï¼Agentä»¬å¼€å§‹è‡ªç”±è¡ŒåŠ¨å’Œäº¤äº’ã€‚", 'system');
}

async function triggerWorldEvent() {
    eventTriggerBtn.disabled = true;
    eventTriggerBtn.textContent = "æ€è€ƒä¸­...";
    logMessage("ğŸ¤” æ­£åœ¨å‘Geminiè¯·æ±‚ä¸€ä¸ªæ–°çš„ä¸–ç•Œäº‹ä»¶...", 'system');
    
    const professionList = Object.keys(PROFESSIONS).join(', ');
    const prompt = `ä¸ºåŒ…å«[${professionList}]çš„è™šæ‹Ÿä¸–ç•Œç”Ÿæˆä¸€ä¸ªæœ‰è¶£çš„ã€ç®€çŸ­çš„çªå‘äº‹ä»¶ã€‚äº‹ä»¶åº”è¯¥èƒ½å½±å“ä»–ä»¬çš„äº’åŠ¨ã€‚ä¾‹å¦‚:â€œå’–å•¡æœºåäº†â€, â€œå®£å¸ƒä¸€ä¸ªæƒŠå–œçš„é¡¹ç›®æˆªæ­¢æ—¥æœŸâ€, â€œWi-Fiæ–­äº†â€ã€‚è¯·åªè¿”å›ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼ä¸º: {"event_name": "äº‹ä»¶æ ‡é¢˜", "description": "äº‹ä»¶çš„ç®€çŸ­æè¿°ã€‚"}`;

    const event = await callGemini(prompt);

    if (!event.error) {
        currentWorldEvent = event;
        logMessage(`ğŸ‰ <strong>ä¸–ç•Œäº‹ä»¶: ${event.event_name}</strong> - ${event.description}`, 'event');
    } else {
        logMessage(`â—ï¸ ç”Ÿæˆä¸–ç•Œäº‹ä»¶å¤±è´¥ã€‚`, 'system');
    }
    
    eventTriggerBtn.disabled = false;
    eventTriggerBtn.textContent = "âœ¨ è§¦å‘ä¸–ç•Œäº‹ä»¶";
}

async function viewInnerThoughts(agentId) {
    const agent = agents.find(a => a.id === agentId);
    if (!agent) return;

    const thoughtBubble = document.getElementById('thought-bubble');
    if(!thoughtBubble) return;
    thoughtBubble.textContent = "æ­£åœ¨æ€è€ƒ...";

    const eventContext = currentWorldEvent ? `å½“å‰ä¸–ç•Œäº‹ä»¶æ˜¯: "${currentWorldEvent.description}".` : "å½“å‰æ²¡æœ‰ç‰¹æ®Šäº‹ä»¶å‘ç”Ÿã€‚";
    const memoryContext = agent.memory.length > 0 ? `ä½ çš„è®°å¿†ä¸­æœ‰è¿™äº›è¿‡å»çš„äº’åŠ¨æ‘˜è¦:\n- ${agent.memory.join('\n- ')}` : "ä½ è¿˜æ²¡æœ‰ä»»ä½•è¿‡å»çš„äº’åŠ¨è®°å¿†ã€‚";

    const prompt = `ä½ å« ${agent.name}ï¼Œæ˜¯ä¸€å${agent.profession}ã€‚
    ä½ çš„è®°å¿†:
    ${agent.memory.join('\n')}
    å½“å‰æƒ…æ™¯:
    ${eventContext}
    ä½ å½“å‰çš„çŠ¶æ€æ˜¯â€œ${agent.state}â€ã€‚
    è¯·ç”¨ç¬¬ä¸€äººç§°ç®€çŸ­æè¿°ä½ æ­¤åˆ»çš„å†…å¿ƒæƒ³æ³•ã€‚è¯·åªè¿”å›ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼ä¸º: {"thought": "ä½ çš„å†…å¿ƒç‹¬ç™½ã€‚"}`;

    const response = await callGemini(prompt);

    if (!response.error) {
        thoughtBubble.textContent = `â€œ${response.thought}â€`;
    } else {
        thoughtBubble.textContent = "æ— æ³•è¯»å–æƒ³æ³•...";
    }
}


// --- SIMULATION LOGIC ---
function init() {
    logMessage("ğŸ‘‹ æ¬¢è¿æ¥åˆ°å¤šAgentæ¨¡æ‹Ÿç³»ç»Ÿã€‚", 'system');
    agents.push(new Agent("è‰¾ä¸½æ–¯", "ç¨‹åºå‘˜"));
    agents.push(new Agent("é²å‹ƒ", "è®¾è®¡å¸ˆ"));
    agents.push(new Agent("æŸ¥ç†", "äº§å“ç»ç†"));
    agents.push(new Agent("é»›å®‰å¨œ", "è‰ºæœ¯å®¶"));
    agents.push(new Agent("ä¼Šä¸‡", "AIä¸“å®¶"));
    
    agents.forEach(agent => agent.updateElement()); // Initial render
    logMessage("âœ… 5ä½Agentå·²å°±ä½ã€‚", 'system');
    logMessage("ğŸ’¡ è¯·ç‚¹å‡»å·¦ä¸Šè§’çš„â€œå¼€å§‹æ¨¡æ‹Ÿâ€æŒ‰é’®ã€‚", 'system');

    startSimBtn.addEventListener('click', startSimulation);
    eventTriggerBtn.addEventListener('click', triggerWorldEvent);
    setInterval(gameLoop, GAME_TICK_MS);
}

async function checkEncounters() {
    for (let i = 0; i < agents.length; i++) {
        for (let j = i + 1; j < agents.length; j++) {
            const agentA = agents[i];
            const agentB = agents[j];

            if (agentA.state !== 'wandering' && agentA.state !== 'finding') continue;
            if (agentB.state !== 'wandering' && agentB.state !== 'finding') continue;

            const distance = getDistance(agentA, agentB);
            if (distance < ENCOUNTER_DISTANCE) {
                const now = Date.now();
                const lastCheckA = agentA.lastEncounterCheck[agentB.id] || 0;
                const lastCheckB = agentB.lastEncounterCheck[agentA.id] || 0;

                if (now - lastCheckA > TALK_INITIATION_COOLDOWN && now - lastCheckB > TALK_INITIATION_COOLDOWN) {
                    agentA.lastEncounterCheck[agentB.id] = now;
                    agentB.lastEncounterCheck[agentA.id] = now;
                    
                    logMessage(`ğŸ¤ ${agentA.name} (${agentA.profession}) å’Œ ${agentB.name} (${agentB.profession}) ç›¸é‡äº†...`, 'system');
                    
                    agentA.state = 'thinking';
                    agentB.state = 'thinking';

                    const decisionA = await agentA.decideToTalk(agentB);

                    if (!decisionA.should_initiate) {
                        logMessage(`- ${agentA.name} å†³å®š: ${decisionA.should_initiate}. åŸå› : ${decisionA.reason}`, 'system');
                        logMessage(`- ç”±äº ${agentA.name} ä¸æƒ³äº¤è°ˆï¼Œå¯¹è¯æœªå‘èµ·ã€‚`, 'system');
                        agentA.state = 'wandering';
                        agentB.state = 'wandering';
                        continue;
                    }

                    const decisionB = await agentB.decideToTalk(agentA);

                    logMessage(`- ${agentA.name} å†³å®š: ${decisionA.should_initiate}. åŸå› : ${decisionA.reason}`, 'system');
                    logMessage(`- ${agentB.name} å†³å®š: ${decisionB.should_initiate}. åŸå› : ${decisionB.reason}`, 'system');

                    if (decisionA.should_initiate && decisionB.should_initiate) {
                        startConversation(agentA, agentB);
                    } else {
                        logMessage(`âŒ å¯¹è¯æœªå‘èµ·ï¼ŒåŒæ–¹æœªè¾¾æˆå…±è¯†ã€‚`, 'system');
                        agentA.state = 'wandering';
                        agentB.state = 'wandering';
                    }
                }
            }
        }
    }
}

function startConversation(agentA, agentB) {
    const conversationId = `conv-${Date.now()}`;
    logMessage(`ğŸ’¬ å¯¹è¯å¼€å§‹! ${agentA.name} ä¸ ${agentB.name}.`, 'dialogue');
    agentA.state = 'talking';
    agentB.state = 'talking';
    agentA.conversationId = conversationId;
    agentB.conversationId = conversationId;
    conversations[conversationId] = { id: conversationId, participants: [agentA.id, agentB.id], history: [], turn: agentA.id, turnCount: 0 };
    agentA.target = { x: agentA.x, y: agentA.y };
    agentB.target = { x: agentB.x, y: agentB.y };
    handleConversationTurn(conversationId);
}

async function handleConversationTurn(conversationId) {
    const conversation = conversations[conversationId];
    if (!conversation) return; // **FIX**: Check if conversation was ended by another process.

    if (conversation.turnCount >= MAX_CONVERSATION_TURNS) {
        endConversation(conversationId, "å¯¹è¯è¾¾åˆ°æœ€å¤§è½®æ¬¡");
        return;
    }
    const currentSpeaker = agents.find(a => a.id === conversation.turn);
    if (!currentSpeaker || currentSpeaker.state !== 'talking') {
        endConversation(conversationId, "ä¸€æ–¹æå‰ç¦»å¼€");
        return;
    }
    const response = await currentSpeaker.generateDialogue(conversation);
    
    // **FIX**: After a potentially long API call, check again if the conversation still exists.
    if (!conversations[conversationId]) return;

    currentSpeaker.displayBubble(response.dialogue);
    logMessage(`<strong>${currentSpeaker.name}:</strong> ${response.dialogue}`, 'dialogue');
    conversation.history.push({ name: currentSpeaker.name, dialogue: response.dialogue });
    conversation.turnCount++;
    
    const action = response.action.action;
    if (action === 'continue_talking') {
        conversation.turn = conversation.participants.find(pId => pId !== currentSpeaker.id);
        setTimeout(() => handleConversationTurn(conversationId), 1000);
    } else {
        // End the conversation immediately for both parties.
        endConversation(conversationId, `${currentSpeaker.name} å†³å®šç»“æŸå¯¹è¯`);
        
        // Then, set the specific action for the agent who decided to leave.
        if (action === 'leave_and_wander') {
            currentSpeaker.setWandering(response.dialogue);
        } else if (action === 'leave_and_find' && response.action.target_profession) {
            currentSpeaker.setFinding(response.action.target_profession, response.dialogue);
        } else {
            currentSpeaker.setWandering("å†³å®šç¦»å¼€ä½†æœªæŒ‡å®šç›®æ ‡");
        }
    }
}

async function summarizeAndStoreMemory(history, participantIds) {
    if (!history || history.length === 0) return;

    const historyText = history.map(h => `${h.name}: ${h.dialogue}`).join('\n');
    const prompt = `è¯·å°†ä»¥ä¸‹å¯¹è¯æ€»ç»“ä¸ºä¸€å¥ç®€çŸ­çš„ã€ä»¥ç¬¬ä¸€äººç§°è§†è§’è®°å½•çš„è®°å¿†ã€‚æ€»ç»“åº”æ•æ‰å¯¹è¯çš„æ ¸å¿ƒè¦ç‚¹æˆ–æ„Ÿå—ã€‚
    å¯¹è¯å†…å®¹:
    ${historyText}
    è¯·åªè¿”å›ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼ä¸º: {"summary": "ä½ çš„æ€»ç»“ã€‚"}`;

    const response = await callGemini(prompt);
    if (response && !response.error && response.summary) {
        logMessage(`ğŸ“ æ–°è®°å¿†å·²å½¢æˆ: "${response.summary}"`, 'memory');
        participantIds.forEach(agentId => {
            const agent = agents.find(a => a.id === agentId);
            if (agent) {
                agent.memory.push(response.summary);
                if (agent.memory.length > 10) {
                    agent.memory.shift();
                }
            }
        });
    }
}


function endConversation(conversationId, reason) {
    const conversation = conversations[conversationId];
    if (!conversation) return;

    logMessage(`ğŸ›‘ å¯¹è¯ ${conversationId.slice(-4)} ç»“æŸã€‚åŸå› : ${reason}`, 'system');
    
    const participantIds = [...conversation.participants];
    const historyForMemory = [...conversation.history];

    // **FIX**: Immediately delete the conversation to prevent other turns from starting.
    delete conversations[conversationId];

    // **FIX**: Set both agents to wandering first to ensure they stop talking.
    participantIds.forEach(agentId => {
        const agent = agents.find(a => a.id === agentId);
        if (agent && agent.conversationId === conversationId) {
            agent.setWandering("å¯¹è¯ç»“æŸ");
        }
    });
    
    // The memory summarization now runs as a background task.
    if (historyForMemory.length > 0) {
        summarizeAndStoreMemory(historyForMemory, participantIds);
    }
}

let encounterCheckRunning = false;
async function gameLoop() {
    // Agent movement and rendering always runs
    agents.forEach(agent => agent.update());

    // Encounter checks only run after the simulation has started
    if (simulationStarted && !encounterCheckRunning) {
        encounterCheckRunning = true;
        try {
            await checkEncounters();
        } catch (e) {
            console.error("Error during encounter check:", e);
            logMessage(`â—ï¸ é­é‡æ£€æµ‹å¾ªç¯å‡ºé”™: ${e.message}`, 'system');
        } finally {
            encounterCheckRunning = false;
        }
    }
}

// --- INITIALIZATION ---
window.onload = init;
</script>
</body>
</html>