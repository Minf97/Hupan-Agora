<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Â§öAgent‰∫§‰∫íÊ®°ÊãüÁ≥ªÁªü (‰ºòÂåñÁâà)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            overflow: hidden;
        }
        .map {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #f0f4f8;
            border-radius: 0.5rem;
            overflow: hidden;
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.04) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.04) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .agent {
            position: absolute;
            width: 64px;
            height: 64px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .agent:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 12px rgba(0,0,0,0.15);
        }
        .agent-avatar {
            font-size: 24px;
        }
        .agent-name {
            font-size: 10px;
            font-weight: 500;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .chat-bubble {
            position: absolute;
            bottom: 75px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 12px;
            max-width: 200px;
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 10;
            border: 1px solid #e2e8f0;
        }
        .chat-bubble.visible {
            opacity: 1;
        }
        .status-indicator {
            position: absolute;
            top: 0;
            right: 0;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
        }
        .status-wandering { background-color: #34d399; } /* green */
        .status-talking { background-color: #fbbf24; } /* amber */
        .status-finding { background-color: #f87171; } /* red */
        .status-thinking { background-color: #60a5fa; } /* blue */

        .log-panel {
            height: 100%;
            overflow-y: auto;
            background-color: #ffffff;
            border-left: 1px solid #e2e8f0;
        }
        .log-item {
            padding: 8px 12px;
            border-bottom: 1px solid #f1f5f9;
            font-size: 13px;
        }
        .log-item.system { color: #64748b; font-style: italic; }
        .log-item.dialogue { color: #1e293b; }
        .log-item.event { background-color: #e0f2fe; color: #0c4a6e; font-weight: 500; border-left: 4px solid #0ea5e9; }
        .log-item.memory { background-color: #fefce8; color: #854d0e; font-style: italic; border-left: 4px solid #facc15;}

        .selected-agent-panel {
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
        }
        .control-button {
            background-color: #8b5cf6;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .control-button:hover {
            background-color: #7c3aed;
            transform: translateY(-2px);
        }
        .control-button:disabled {
            background-color: #a78bfa;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="w-screen h-screen p-4 flex gap-4">
        <!-- Main Map Area -->
        <div class="w-3/4 h-full flex flex-col gap-4">
            <div class="flex-grow relative">
                <div id="map" class="map"></div>
                <div id="controls" class="absolute top-2 left-2 flex gap-2">
                    <button id="start-sim-btn" class="control-button">üöÄ ÂºÄÂßãÊ®°Êãü</button>
                    <button id="event-trigger-btn" class="control-button hidden">‚ú® Ëß¶Âèë‰∏ñÁïå‰∫ã‰ª∂</button>
                </div>
            </div>
            <div id="selected-agent-panel" class="h-48 p-4 border border-gray-200 rounded-lg shadow-sm selected-agent-panel hidden">
                <h3 class="font-bold text-lg">ÈÄâ‰∏≠ÁöÑAgent‰ø°ÊÅØ</h3>
                <div id="agent-details" class="mt-2 text-sm grid grid-cols-2 gap-x-4"></div>
            </div>
        </div>

        <!-- Log Panel -->
        <div class="w-1/4 h-full flex flex-col bg-white rounded-lg shadow-md">
            <h2 class="text-lg font-bold p-4 border-b border-gray-200">Á≥ªÁªüÊó•Âøó‰∏éÂØπËØù</h2>
            <div id="log-panel" class="flex-grow overflow-y-auto p-2">
                <!-- Logs will be appended here -->
            </div>
        </div>
    </div>

<script>
// --- CONFIGURATION ---
const apiKey = ""; // This is a placeholder, the environment will handle authentication.
const modelName = "gemini-2.0-flash";
const baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent`;

const AGENT_SPEED = 1.5; // **FIX**: Increased speed
const ENCOUNTER_DISTANCE = 100;
const GAME_TICK_MS = 100;
const TALK_INITIATION_COOLDOWN = 10000;
const MAX_CONVERSATION_TURNS = 10;

// --- DOM ELEMENTS ---
const mapElement = document.getElementById('map');
const logPanel = document.getElementById('log-panel');
const selectedAgentPanel = document.getElementById('selected-agent-panel');
const agentDetails = document.getElementById('agent-details');
const startSimBtn = document.getElementById('start-sim-btn');
const eventTriggerBtn = document.getElementById('event-trigger-btn');


// --- GLOBAL STATE ---
const PROFESSIONS = {
    "Á®ãÂ∫èÂëò": { emoji: "üíª", color: "bg-blue-500" },
    "ËÆæËÆ°Â∏à": { emoji: "üé®", color: "bg-purple-500" },
    "‰∫ßÂìÅÁªèÁêÜ": { emoji: "üìà", color: "bg-green-500" },
    "Ëâ∫ÊúØÂÆ∂": { emoji: "üé≠", color: "bg-pink-500" },
    "AI‰∏ìÂÆ∂": { emoji: "ü§ñ", color: "bg-indigo-500" }
};
let agents = [];
let conversations = {};
let nextAgentId = 0;
let currentWorldEvent = null;
let simulationStarted = false;

// --- UTILITY FUNCTIONS ---
const getRandomPosition = () => ({
    x: Math.random() * (mapElement.clientWidth - 64),
    y: Math.random() * (mapElement.clientHeight - 64)
});

const getDistance = (agent1, agent2) => {
    return Math.sqrt(Math.pow(agent1.x - agent2.x, 2) + Math.pow(agent1.y - agent2.y, 2));
};

function logMessage(message, type = 'system') {
    const item = document.createElement('div');
    item.className = `log-item ${type}`;
    item.innerHTML = message;
    logPanel.appendChild(item);
    logPanel.scrollTop = logPanel.scrollHeight;
}

// --- GEMINI API CALLER ---
async function callGemini(prompt) {
    try {
        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
                responseMimeType: "application/json",
            }
        };
        const finalUrl = `${baseUrl}?key=${apiKey}`;

        const response = await fetch(finalUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`API call failed with status: ${response.status}. Body: ${errorBody}`);
        }
        const data = await response.json();
        if (data.candidates && data.candidates.length > 0) {
            const rawText = data.candidates[0].content.parts[0].text;
            try {
                return JSON.parse(rawText);
            } catch (e) {
                console.error("Failed to parse JSON from Gemini:", rawText);
                throw new Error("Invalid JSON response from API.");
            }
        }
        throw new Error("Invalid response structure from API.");
    } catch (error) {
        console.error("Gemini API Error:", error);
        logMessage(`‚ùóÔ∏è APIË∞ÉÁî®Â§±Ë¥•: ${error.message}`, 'system');
        return { error: true, message: error.message };
    }
}

// --- AGENT CLASS ---
class Agent {
    constructor(name, profession) {
        this.id = `agent-${nextAgentId++}`;
        this.name = name;
        this.profession = profession;
        const pos = getRandomPosition();
        this.x = pos.x;
        this.y = pos.y;
        this.state = 'wandering';
        this.motivation = { action: 'wander' };
        this.target = getRandomPosition();
        this.lastEncounterCheck = {};
        this.conversationId = null;
        this.lastMessage = "";
        this.memory = [];
        this.createElement();
    }

    createElement() {
        this.element = document.createElement('div');
        this.element.id = this.id;
        this.element.className = `agent ${PROFESSIONS[this.profession].color}`;
        this.element.innerHTML = `
            <div class="agent-avatar">${PROFESSIONS[this.profession].emoji}</div>
            <div class="agent-name">${this.name}</div>
            <div class="status-indicator"></div>
            <div class="chat-bubble"></div>
        `;
        mapElement.appendChild(this.element);
        this.element.addEventListener('click', () => this.showDetails());
    }

    update() {
        this.move();
        this.updateElement();
    }

    move() {
        if (this.state === 'talking' || this.state === 'thinking' || !simulationStarted) return;
        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 5) {
            if (this.state === 'finding') {
                this.setWandering(`Âú®ÂØªÊâæ${this.motivation.target_profession}ÂêéÂºÄÂßãÈó≤ÈÄõ`);
            } else {
                this.target = getRandomPosition();
            }
        } else {
            this.x += (dx / distance) * AGENT_SPEED;
            this.y += (dy / distance) * AGENT_SPEED;
        }
    }
    
    setWandering(reason) {
        if (this.state === 'talking') {
             logMessage(`üö∂ ${this.name} ÁªìÊùü‰∫ÜÂØπËØùÂπ∂ÂºÄÂßãÈó≤ÈÄõ„ÄÇÂéüÂõ†: ${reason}`);
        }
        this.state = 'wandering';
        this.motivation = { action: 'wander' };
        this.target = getRandomPosition();
        this.conversationId = null;
    }

    setFinding(targetProfession, reason) {
        logMessage(`üéØ ${this.name} ÂÜ≥ÂÆöÂéªÂØªÊâæ‰∏Ä‰Ωç ${targetProfession}„ÄÇÂéüÂõ†: ${reason}`);
        this.state = 'finding';
        this.motivation = { action: 'find', target: targetProfession };
        this.conversationId = null;
        const targetAgent = agents.find(a => a.profession === targetProfession && a.id !== this.id);
        if (targetAgent) {
            this.target = { x: targetAgent.x, y: targetAgent.y };
            logMessage(`${this.name} ÂèëÁé∞‰∫Ü ${targetAgent.name} (${targetProfession})ÔºåÊ≠£Âú®ÂâçÂæÄ„ÄÇ`);
        } else {
            this.target = getRandomPosition();
            logMessage(`Âú∞Âõæ‰∏äÊöÇÊó∂Ê≤°Êúâ ${targetProfession}Ôºå${this.name} ÂÖàÂõõÂ§ÑÁúãÁúã„ÄÇ`);
        }
    }

    updateElement() {
        this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
        const statusIndicator = this.element.querySelector('.status-indicator');
        statusIndicator.className = `status-indicator status-${this.state}`;
    }
    
    showDetails() {
        selectedAgentPanel.classList.remove('hidden');
        const memoryHtml = this.memory.length > 0 ? this.memory.map(m => `<li>- ${m}</li>`).join('') : '<li>ÊöÇÊó†ËÆ∞ÂøÜ</li>';
        agentDetails.innerHTML = `
            <div>
                <p><strong>ÂßìÂêç:</strong> ${this.name} (${this.id})</p>
                <p><strong>ËÅå‰∏ö:</strong> ${this.profession}</p>
                <p><strong>Áä∂ÊÄÅ:</strong> ${this.state}</p>
                <p><strong>ÊúÄËøëÁöÑËØù:</strong> ${this.lastMessage || 'Êó†'}</p>
                <div class="mt-2">
                    <strong>ËÆ∞ÂøÜ:</strong>
                    <ul class="list-disc list-inside text-xs h-16 overflow-y-auto">${memoryHtml}</ul>
                </div>
            </div>
            <div class="flex flex-col items-start gap-2">
                 <button onclick="viewInnerThoughts('${this.id}')" class="control-button" style="font-size:12px; padding: 4px 8px;">‚ú® Êü•ÁúãÂÜÖÂøÉÊÉ≥Ê≥ï</button>
                 <div id="thought-bubble" class="text-xs italic text-gray-600 mt-1 p-2 bg-gray-100 rounded">ÁÇπÂáªÊåâÈíÆÊù•Êü•Áúã...</div>
            </div>
        `;
    }

    displayBubble(message) {
        this.lastMessage = message;
        const bubble = this.element.querySelector('.chat-bubble');
        bubble.textContent = message;
        bubble.classList.add('visible');
        setTimeout(() => bubble.classList.remove('visible'), 5000);
    }

    async decideToTalk(otherAgent) {
        this.state = 'thinking';
        const eventContext = currentWorldEvent ? `ÂΩìÂâç‰∏ñÁïå‰∫ã‰ª∂ÊòØ: "${currentWorldEvent.description}".` : "ÂΩìÂâçÊ≤°ÊúâÁâπÊÆä‰∫ã‰ª∂ÂèëÁîü„ÄÇ";
        const memoryContext = this.memory.length > 0 ? `‰Ω†ÁöÑËÆ∞ÂøÜ‰∏≠ÊúâËøô‰∫õËøáÂéªÁöÑ‰∫íÂä®ÊëòË¶Å:\n- ${this.memory.join('\n- ')}` : "‰Ω†ËøòÊ≤°Êúâ‰ªª‰ΩïËøáÂéªÁöÑ‰∫íÂä®ËÆ∞ÂøÜ„ÄÇ";

        const prompt = `‰Ω†Âè´ ${this.name}ÔºåÊòØ‰∏ÄÂêç${this.profession}„ÄÇ
        ${memoryContext}
        ${eventContext}
        ‰Ω†ÂΩìÂâçÁöÑÂä®Êú∫ÊòØ ${JSON.stringify(this.motivation)}„ÄÇ
        ‰Ω†Áé∞Âú®ÈÅáÂà∞‰∫Ü ${otherAgent.name} (${otherAgent.profession})„ÄÇ
        Âü∫‰∫é‰Ω†ÁöÑËÆ∞ÂøÜÂíåÂΩìÂâçÊÉÖÂÜµÔºå‰Ω†ÊòØÂê¶ÊÉ≥ÂíåTAÂèëËµ∑ÂØπËØùÔºüËØ∑Âè™ËøîÂõû‰∏Ä‰∏™JSONÂØπË±°ÔºåÊ†ºÂºè‰∏∫: {"should_initiate": boolean, "reason": "‰Ω†ÁöÑÁêÜÁî±"}`;
        
        const decision = await callGemini(prompt);
        if (decision.error) {
            return { should_initiate: false, reason: `AIÂÜ≥Á≠ñÊó∂ÂèëÁîüÈîôËØØ: ${decision.message}` };
        }
        return decision;
    }
    
    async generateDialogue(conversation) {
        this.state = 'thinking';
        const otherAgent = agents.find(a => a.id === conversation.participants.find(pId => pId !== this.id));
        const history = conversation.history.map(h => `${h.name}: ${h.dialogue}`).join('\n');
        const eventContext = currentWorldEvent ? `ÂΩìÂâç‰∏ñÁïå‰∫ã‰ª∂ÊòØ: "${currentWorldEvent.description}".` : "ÂΩìÂâçÊ≤°ÊúâÁâπÊÆä‰∫ã‰ª∂ÂèëÁîü„ÄÇ";
        const memoryContext = this.memory.length > 0 ? `‰Ω†ÁöÑËÆ∞ÂøÜ‰∏≠ÊúâËøô‰∫õËøáÂéªÁöÑ‰∫íÂä®ÊëòË¶Å:\n- ${this.memory.join('\n- ')}` : "‰Ω†ËøòÊ≤°Êúâ‰ªª‰ΩïËøáÂéªÁöÑ‰∫íÂä®ËÆ∞ÂøÜ„ÄÇ";

        const prompt = `
        ‰Ω†Âè´ ${this.name}ÔºåÊòØ‰∏ÄÂêç${this.profession}„ÄÇ
        ËßÑÂàô: ‰Ω†ÁöÑËØùË¶ÅÁÆÄÁü≠„ÄÅÁõ¥Êé•Ôºå‰∏çË¶ÅÂ§™ÂÆ¢Ê∞î„ÄÇ
        ‰Ω†ÁöÑËÆ∞ÂøÜ:
        ${this.memory.join('\n')}
        
        ÂΩìÂâçÊÉÖÊôØ:
        Â§ßËÉåÊôØ: ${eventContext}
        ‰Ω†Ê≠£Âú®Âíå ${otherAgent.name} (${otherAgent.profession}) ÂØπËØù„ÄÇ
        ÂØπËØùÂéÜÂè≤:
        ${history || "ÔºàËøôÊòØÂØπËØùÁöÑÁ¨¨‰∏ÄÂè•ËØùÔºâ"}

        Áé∞Âú®ËΩÆÂà∞‰Ω†ÂèëË®Ä„ÄÇËØ∑Ê†πÊçÆ‰Ω†ÁöÑËÆ∞ÂøÜÂíåÂΩìÂâçÂØπËØùÔºåÁîüÊàê‰Ω†ÁöÑ‰∏ã‰∏ÄÂè•ËØùÔºåÂπ∂ÂÜ≥ÂÆö‰∏ã‰∏ÄÊ≠•Ë°åÂä®„ÄÇ
        Ë°åÂä®ÈÄâÈ°π: "continue_talking", "leave_and_wander", "leave_and_find"„ÄÇ
        ËØ∑Âè™ËøîÂõû‰∏Ä‰∏™JSONÂØπË±°ÔºåÊ†ºÂºè‰∏∫:
        { "dialogue": "‰Ω†Ë¶ÅËØ¥ÁöÑËØù", "action": { "action": "..." } }
        `;
        
        const response = await callGemini(prompt);
        if (this.state === 'thinking') this.state = 'talking';
        if (response.error) {
            return { dialogue: "ÊàëÂ•ΩÂÉèÊúâÁÇπËµ∞Á•û‰∫Ü...", action: { action: "leave_and_wander" } };
        }
        return response;
    }
}

// --- NEW/UPDATED FEATURES ---
function startSimulation() {
    simulationStarted = true;
    startSimBtn.classList.add('hidden');
    eventTriggerBtn.classList.remove('hidden');
    logMessage("üöÄ Ê®°ÊãüÂ∑≤ÂºÄÂßãÔºÅAgent‰ª¨ÂºÄÂßãËá™Áî±Ë°åÂä®Âíå‰∫§‰∫í„ÄÇ", 'system');
}

async function triggerWorldEvent() {
    eventTriggerBtn.disabled = true;
    eventTriggerBtn.textContent = "ÊÄùËÄÉ‰∏≠...";
    logMessage("ü§î Ê≠£Âú®ÂêëGeminiËØ∑Ê±Ç‰∏Ä‰∏™Êñ∞ÁöÑ‰∏ñÁïå‰∫ã‰ª∂...", 'system');
    
    const professionList = Object.keys(PROFESSIONS).join(', ');
    const prompt = `‰∏∫ÂåÖÂê´[${professionList}]ÁöÑËôöÊãü‰∏ñÁïåÁîüÊàê‰∏Ä‰∏™ÊúâË∂£ÁöÑ„ÄÅÁÆÄÁü≠ÁöÑÁ™ÅÂèë‰∫ã‰ª∂„ÄÇ‰∫ã‰ª∂Â∫îËØ•ËÉΩÂΩ±Âìç‰ªñ‰ª¨ÁöÑ‰∫íÂä®„ÄÇ‰æãÂ¶Ç:‚ÄúÂíñÂï°Êú∫Âùè‰∫Ü‚Äù, ‚ÄúÂÆ£Â∏É‰∏Ä‰∏™ÊÉäÂñúÁöÑÈ°πÁõÆÊà™Ê≠¢Êó•Êúü‚Äù, ‚ÄúWi-FiÊñ≠‰∫Ü‚Äù„ÄÇËØ∑Âè™ËøîÂõû‰∏Ä‰∏™JSONÂØπË±°ÔºåÊ†ºÂºè‰∏∫: {"event_name": "‰∫ã‰ª∂Ê†áÈ¢ò", "description": "‰∫ã‰ª∂ÁöÑÁÆÄÁü≠ÊèèËø∞„ÄÇ"}`;

    const event = await callGemini(prompt);

    if (!event.error) {
        currentWorldEvent = event;
        logMessage(`üéâ <strong>‰∏ñÁïå‰∫ã‰ª∂: ${event.event_name}</strong> - ${event.description}`, 'event');
    } else {
        logMessage(`‚ùóÔ∏è ÁîüÊàê‰∏ñÁïå‰∫ã‰ª∂Â§±Ë¥•„ÄÇ`, 'system');
    }
    
    eventTriggerBtn.disabled = false;
    eventTriggerBtn.textContent = "‚ú® Ëß¶Âèë‰∏ñÁïå‰∫ã‰ª∂";
}

async function viewInnerThoughts(agentId) {
    const agent = agents.find(a => a.id === agentId);
    if (!agent) return;

    const thoughtBubble = document.getElementById('thought-bubble');
    if(!thoughtBubble) return;
    thoughtBubble.textContent = "Ê≠£Âú®ÊÄùËÄÉ...";

    const eventContext = currentWorldEvent ? `ÂΩìÂâç‰∏ñÁïå‰∫ã‰ª∂ÊòØ: "${currentWorldEvent.description}".` : "ÂΩìÂâçÊ≤°ÊúâÁâπÊÆä‰∫ã‰ª∂ÂèëÁîü„ÄÇ";
    const memoryContext = agent.memory.length > 0 ? `‰Ω†ÁöÑËÆ∞ÂøÜ‰∏≠ÊúâËøô‰∫õËøáÂéªÁöÑ‰∫íÂä®ÊëòË¶Å:\n- ${agent.memory.join('\n- ')}` : "‰Ω†ËøòÊ≤°Êúâ‰ªª‰ΩïËøáÂéªÁöÑ‰∫íÂä®ËÆ∞ÂøÜ„ÄÇ";

    const prompt = `‰Ω†Âè´ ${agent.name}ÔºåÊòØ‰∏ÄÂêç${agent.profession}„ÄÇ
    ‰Ω†ÁöÑËÆ∞ÂøÜ:
    ${agent.memory.join('\n')}
    ÂΩìÂâçÊÉÖÊôØ:
    ${eventContext}
    ‰Ω†ÂΩìÂâçÁöÑÁä∂ÊÄÅÊòØ‚Äú${agent.state}‚Äù„ÄÇ
    ËØ∑Áî®Á¨¨‰∏Ä‰∫∫Áß∞ÁÆÄÁü≠ÊèèËø∞‰Ω†Ê≠§ÂàªÁöÑÂÜÖÂøÉÊÉ≥Ê≥ï„ÄÇËØ∑Âè™ËøîÂõû‰∏Ä‰∏™JSONÂØπË±°ÔºåÊ†ºÂºè‰∏∫: {"thought": "‰Ω†ÁöÑÂÜÖÂøÉÁã¨ÁôΩ„ÄÇ"}`;

    const response = await callGemini(prompt);

    if (!response.error) {
        thoughtBubble.textContent = `‚Äú${response.thought}‚Äù`;
    } else {
        thoughtBubble.textContent = "Êó†Ê≥ïËØªÂèñÊÉ≥Ê≥ï...";
    }
}


// --- SIMULATION LOGIC ---
function init() {
    logMessage("üëã Ê¨¢ËøéÊù•Âà∞Â§öAgentÊ®°ÊãüÁ≥ªÁªü„ÄÇ", 'system');
    agents.push(new Agent("Ëâæ‰∏ΩÊñØ", "Á®ãÂ∫èÂëò"));
    agents.push(new Agent("È≤çÂãÉ", "ËÆæËÆ°Â∏à"));
    agents.push(new Agent("Êü•ÁêÜ", "‰∫ßÂìÅÁªèÁêÜ"));
    agents.push(new Agent("ÈªõÂÆâÂ®ú", "Ëâ∫ÊúØÂÆ∂"));
    agents.push(new Agent("‰ºä‰∏á", "AI‰∏ìÂÆ∂"));
    
    agents.forEach(agent => agent.updateElement()); // Initial render
    logMessage("‚úÖ 5‰ΩçAgentÂ∑≤Â∞±‰Ωç„ÄÇ", 'system');
    logMessage("üí° ËØ∑ÁÇπÂáªÂ∑¶‰∏äËßíÁöÑ‚ÄúÂºÄÂßãÊ®°Êãü‚ÄùÊåâÈíÆ„ÄÇ", 'system');

    startSimBtn.addEventListener('click', startSimulation);
    eventTriggerBtn.addEventListener('click', triggerWorldEvent);
    setInterval(gameLoop, GAME_TICK_MS);
}

async function checkEncounters() {
    for (let i = 0; i < agents.length; i++) {
        for (let j = i + 1; j < agents.length; j++) {
            const agentA = agents[i];
            const agentB = agents[j];

            if (agentA.state !== 'wandering' && agentA.state !== 'finding') continue;
            if (agentB.state !== 'wandering' && agentB.state !== 'finding') continue;

            const distance = getDistance(agentA, agentB);
            if (distance < ENCOUNTER_DISTANCE) {
                const now = Date.now();
                const lastCheckA = agentA.lastEncounterCheck[agentB.id] || 0;
                const lastCheckB = agentB.lastEncounterCheck[agentA.id] || 0;

                if (now - lastCheckA > TALK_INITIATION_COOLDOWN && now - lastCheckB > TALK_INITIATION_COOLDOWN) {
                    agentA.lastEncounterCheck[agentB.id] = now;
                    agentB.lastEncounterCheck[agentA.id] = now;
                    
                    logMessage(`ü§ù ${agentA.name} (${agentA.profession}) Âíå ${agentB.name} (${agentB.profession}) Áõ∏ÈÅá‰∫Ü...`, 'system');
                    
                    agentA.state = 'thinking';
                    agentB.state = 'thinking';

                    const decisionA = await agentA.decideToTalk(agentB);

                    if (!decisionA.should_initiate) {
                        logMessage(`- ${agentA.name} ÂÜ≥ÂÆö: ${decisionA.should_initiate}. ÂéüÂõ†: ${decisionA.reason}`, 'system');
                        logMessage(`- Áî±‰∫é ${agentA.name} ‰∏çÊÉ≥‰∫§Ë∞àÔºåÂØπËØùÊú™ÂèëËµ∑„ÄÇ`, 'system');
                        agentA.state = 'wandering';
                        agentB.state = 'wandering';
                        continue;
                    }

                    const decisionB = await agentB.decideToTalk(agentA);

                    logMessage(`- ${agentA.name} ÂÜ≥ÂÆö: ${decisionA.should_initiate}. ÂéüÂõ†: ${decisionA.reason}`, 'system');
                    logMessage(`- ${agentB.name} ÂÜ≥ÂÆö: ${decisionB.should_initiate}. ÂéüÂõ†: ${decisionB.reason}`, 'system');

                    if (decisionA.should_initiate && decisionB.should_initiate) {
                        startConversation(agentA, agentB);
                    } else {
                        logMessage(`‚ùå ÂØπËØùÊú™ÂèëËµ∑ÔºåÂèåÊñπÊú™ËææÊàêÂÖ±ËØÜ„ÄÇ`, 'system');
                        agentA.state = 'wandering';
                        agentB.state = 'wandering';
                    }
                }
            }
        }
    }
}

function startConversation(agentA, agentB) {
    const conversationId = `conv-${Date.now()}`;
    logMessage(`üí¨ ÂØπËØùÂºÄÂßã! ${agentA.name} ‰∏é ${agentB.name}.`, 'dialogue');
    agentA.state = 'talking';
    agentB.state = 'talking';
    agentA.conversationId = conversationId;
    agentB.conversationId = conversationId;
    conversations[conversationId] = { id: conversationId, participants: [agentA.id, agentB.id], history: [], turn: agentA.id, turnCount: 0 };
    agentA.target = { x: agentA.x, y: agentA.y };
    agentB.target = { x: agentB.x, y: agentB.y };
    handleConversationTurn(conversationId);
}

async function handleConversationTurn(conversationId) {
    const conversation = conversations[conversationId];
    if (!conversation) return; // **FIX**: Check if conversation was ended by another process.

    if (conversation.turnCount >= MAX_CONVERSATION_TURNS) {
        endConversation(conversationId, "ÂØπËØùËææÂà∞ÊúÄÂ§ßËΩÆÊ¨°");
        return;
    }
    const currentSpeaker = agents.find(a => a.id === conversation.turn);
    if (!currentSpeaker || currentSpeaker.state !== 'talking') {
        endConversation(conversationId, "‰∏ÄÊñπÊèêÂâçÁ¶ªÂºÄ");
        return;
    }
    const response = await currentSpeaker.generateDialogue(conversation);
    
    // **FIX**: After a potentially long API call, check again if the conversation still exists.
    if (!conversations[conversationId]) return;

    currentSpeaker.displayBubble(response.dialogue);
    logMessage(`<strong>${currentSpeaker.name}:</strong> ${response.dialogue}`, 'dialogue');
    conversation.history.push({ name: currentSpeaker.name, dialogue: response.dialogue });
    conversation.turnCount++;
    
    const action = response.action.action;
    if (action === 'continue_talking') {
        conversation.turn = conversation.participants.find(pId => pId !== currentSpeaker.id);
        setTimeout(() => handleConversationTurn(conversationId), 1000);
    } else {
        // End the conversation immediately for both parties.
        endConversation(conversationId, `${currentSpeaker.name} ÂÜ≥ÂÆöÁªìÊùüÂØπËØù`);
        
        // Then, set the specific action for the agent who decided to leave.
        if (action === 'leave_and_wander') {
            currentSpeaker.setWandering(response.dialogue);
        } else if (action === 'leave_and_find' && response.action.target_profession) {
            currentSpeaker.setFinding(response.action.target_profession, response.dialogue);
        } else {
            currentSpeaker.setWandering("ÂÜ≥ÂÆöÁ¶ªÂºÄ‰ΩÜÊú™ÊåáÂÆöÁõÆÊ†á");
        }
    }
}

async function summarizeAndStoreMemory(history, participantIds) {
    if (!history || history.length === 0) return;

    const historyText = history.map(h => `${h.name}: ${h.dialogue}`).join('\n');
    const prompt = `ËØ∑Â∞Ü‰ª•‰∏ãÂØπËØùÊÄªÁªì‰∏∫‰∏ÄÂè•ÁÆÄÁü≠ÁöÑ„ÄÅ‰ª•Á¨¨‰∏Ä‰∫∫Áß∞ËßÜËßíËÆ∞ÂΩïÁöÑËÆ∞ÂøÜ„ÄÇÊÄªÁªìÂ∫îÊçïÊçâÂØπËØùÁöÑÊ†∏ÂøÉË¶ÅÁÇπÊàñÊÑüÂèó„ÄÇ
    ÂØπËØùÂÜÖÂÆπ:
    ${historyText}
    ËØ∑Âè™ËøîÂõû‰∏Ä‰∏™JSONÂØπË±°ÔºåÊ†ºÂºè‰∏∫: {"summary": "‰Ω†ÁöÑÊÄªÁªì„ÄÇ"}`;

    const response = await callGemini(prompt);
    if (response && !response.error && response.summary) {
        logMessage(`üìù Êñ∞ËÆ∞ÂøÜÂ∑≤ÂΩ¢Êàê: "${response.summary}"`, 'memory');
        participantIds.forEach(agentId => {
            const agent = agents.find(a => a.id === agentId);
            if (agent) {
                agent.memory.push(response.summary);
                if (agent.memory.length > 10) {
                    agent.memory.shift();
                }
            }
        });
    }
}


function endConversation(conversationId, reason) {
    const conversation = conversations[conversationId];
    if (!conversation) return;

    logMessage(`üõë ÂØπËØù ${conversationId.slice(-4)} ÁªìÊùü„ÄÇÂéüÂõ†: ${reason}`, 'system');
    
    const participantIds = [...conversation.participants];
    const historyForMemory = [...conversation.history];

    // **FIX**: Immediately delete the conversation to prevent other turns from starting.
    delete conversations[conversationId];

    // **FIX**: Set both agents to wandering first to ensure they stop talking.
    participantIds.forEach(agentId => {
        const agent = agents.find(a => a.id === agentId);
        if (agent && agent.conversationId === conversationId) {
            agent.setWandering("ÂØπËØùÁªìÊùü");
        }
    });
    
    // The memory summarization now runs as a background task.
    if (historyForMemory.length > 0) {
        summarizeAndStoreMemory(historyForMemory, participantIds);
    }
}

let encounterCheckRunning = false;
async function gameLoop() {
    // Agent movement and rendering always runs
    agents.forEach(agent => agent.update());

    // Encounter checks only run after the simulation has started
    if (simulationStarted && !encounterCheckRunning) {
        encounterCheckRunning = true;
        try {
            await checkEncounters();
        } catch (e) {
            console.error("Error during encounter check:", e);
            logMessage(`‚ùóÔ∏è ÈÅ≠ÈÅáÊ£ÄÊµãÂæ™ÁéØÂá∫Èîô: ${e.message}`, 'system');
        } finally {
            encounterCheckRunning = false;
        }
    }
}

// --- INITIALIZATION ---
window.onload = init;
</script>
</body>
</html>